<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" 
          content="default-src 'self'; 
                   script-src 'self' 'unsafe-inline' https://d3js.org; 
                   style-src 'self' 'unsafe-inline'; 
                   connect-src 'self' https://raw.githubusercontent.com https://cdn.jsdelivr.net;
                   img-src 'self' data:;
                   object-src 'none';
                   base-uri 'self';">
    <title>MITRE ATT&CK v18 Detection Depth Map - Mobile Ready</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --panel-bg: #1e1e1e;
            --border-color: #333;
            --accent-color: #00bcd4;
            --success-color: #2e7d32;
            --warning-color: #fbc02d;
            --danger-color: #d32f2f;
            --focus-ring: 0 0 0 2px var(--accent-color);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Accessibility Focus Styles */
        button:focus-visible, 
        input:focus-visible, 
        .tab-button:focus-visible,
        .layer-checkbox:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .spinner {
            width: 50px; height: 50px;
            border: 4px solid #333;
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #loading-text { margin-top: 20px; font-family: monospace; color: var(--accent-color); font-size: 1.1em;}
        #loading-subtext { color: #888; font-size: 0.9rem; margin-top: 8px; }

        #sidebar {
            width: 380px;
            background-color: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 0;
            box-shadow: 2px 0 5px rgba(0,0,0,0.5);
            z-index: 10;
            overflow: hidden;
            flex-shrink: 0;
        }

        /* Tab System */
        .tab-header {
            display: flex;
            background-color: #0a0a0a;
            border-bottom: 2px solid var(--border-color);
            padding: 0;
            margin: 0;
        }

        .tab-button {
            flex: 1;
            background: transparent;
            color: #888;
            border: none;
            border-bottom: 3px solid transparent;
            padding: 15px 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.85rem;
            transition: all 0.2s;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tab-button:hover {
            background: rgba(255,255,255,0.05);
            color: #aaa;
        }

        .tab-button.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
            background: rgba(0, 188, 212, 0.1);
        }

        .tab-badge {
            display: inline-block;
            background: var(--accent-color);
            color: #000;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 0.7rem;
            font-weight: bold;
            margin-left: 5px;
            min-width: 18px;
            text-align: center;
        }

        .tab-button:not(.active) .tab-badge {
            background: #555;
            color: #aaa;
        }

        .tab-content {
            display: none;
            flex-direction: column;
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .tab-content.active {
            display: flex;
        }

        .tab-content button {
            margin-top: 10px;
        }

        .tab-content button:first-of-type {
            margin-top: 0;
        }

        #main-view {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
            overflow: hidden;
        }
        
        #chart {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #chart svg {
            max-width: 100%;
            max-height: 100%;
        }

        h1 { font-size: 1.2rem; color: var(--accent-color); letter-spacing: 1px; margin: 0 0 5px 0; }
        h2 { font-size: 1rem; color: var(--accent-color); letter-spacing: 0.5px; margin: 20px 0 10px 0; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        .subtitle { font-size: 0.8rem; color: #888; margin-bottom: 20px; }
        
        .score-card {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
        }
        .score-big { font-size: 2.5rem; font-weight: bold; color: #fff; }
        .score-label { font-size: 0.75rem; text-transform: uppercase; color: #aaa; letter-spacing: 1px; }

        .control-group { margin-top: 15px; }
        
        button {
            background: var(--accent-color);
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
            font-size: 0.9rem;
        }
        button:hover { background: #00acc1; }
        button:disabled { background: #555; cursor: not-allowed; opacity: 0.5; }
        button.secondary { background: #333; color: #fff; margin-top: 10px; }
        button.danger { background: var(--danger-color); color: #fff; }
        button.small { padding: 5px 10px; font-size: 0.8rem; width: auto; }

        #tooltip {
            position: fixed;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #555;
            padding: 12px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 0.85rem;
            max-width: 350px;
            opacity: 0;
            transition: opacity 0.15s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 100;
        }

        #breadcrumbs {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 0.9rem;
            color: #00bcd4;
            background: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none;
            max-width: 80%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .meta-tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            margin-top: 5px;
            background: #333;
            color: #ccc;
        }
        
        .id-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-bottom: 8px;
            background: rgba(0, 188, 212, 0.2);
            color: #00bcd4;
            border: 1px solid #00bcd4;
        }
        
        .log-source {
            font-size: 0.7rem;
            color: #888;
            margin-top: 2px;
        }

        /* Layer Management */
        .layer-item {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .layer-item.active {
            border-color: var(--accent-color);
            background: rgba(0, 188, 212, 0.1);
        }

        .layer-item.warning {
            border-color: var(--warning-color);
            background: rgba(251, 192, 45, 0.1);
        }

        .layer-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .layer-info {
            flex: 1;
            min-width: 0;
        }

        .layer-name {
            font-weight: bold;
            font-size: 0.85rem;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-stats {
            font-size: 0.7rem;
            color: #888;
            margin-top: 2px;
        }

        .layer-warning {
            font-size: 0.7rem;
            color: var(--warning-color);
            margin-top: 2px;
        }

        .layer-actions {
            display: flex;
            gap: 5px;
        }

        .layer-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            display: inline-block;
            margin-right: 5px;
        }

        #file-input {
            display: none;
        }

        .file-drop-zone {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-drop-zone:hover, .file-drop-zone:focus {
            border-color: var(--accent-color);
            background: rgba(0, 188, 212, 0.05);
            outline: none;
        }

        .file-drop-zone.drag-over {
            border-color: var(--accent-color);
            background: rgba(0, 188, 212, 0.1);
        }

        .help-text {
            font-size: 0.75rem;
            color: #666;
            margin-top: 5px;
            line-height: 1.4;
        }

        .schema-example {
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px;
            font-family: monospace;
            font-size: 0.7rem;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .collapsible-section {
            margin-top: 15px;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        
        .collapsible-header:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        .collapsible-header:hover {
            background: rgba(255,255,255,0.08);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.open {
            max-height: 500px;
            overflow-y: auto;
        }

        /* Notification System */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 4px;
            max-width: 400px;
            z-index: 1001;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            animation: slideIn 0.3s ease;
            word-wrap: break-word;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .notification-actions {
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }
        
        .notification-btn {
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .notification-btn:hover {
            background: rgba(0,0,0,0.4);
        }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .notification-error {
            background: var(--danger-color);
            color: white;
        }

        .notification-warning {
            background: var(--warning-color);
            color: #000;
        }

        .notification-success {
            background: var(--success-color);
            color: white;
        }

        .notification-info {
            background: var(--accent-color);
            color: #000;
        }

        .notification strong {
            display: block;
            margin-bottom: 5px;
            font-size: 1em;
        }

        .notification details {
            margin-top: 10px;
            font-size: 0.8em;
            cursor: pointer;
        }

        .notification details pre {
            margin-top: 5px;
            padding: 5px;
            background: rgba(0,0,0,0.2);
            border-radius: 2px;
            overflow-x: auto;
            max-height: 200px;
        }

        /* Loading overlay for layer import */
        #layer-import-loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border-radius: 8px;
            z-index: 999;
            text-align: center;
            border: 2px solid var(--accent-color);
        }

        #layer-import-loading .spinner {
            margin: 0 auto;
        }

        #layer-import-loading div {
            color: var(--accent-color);
            margin-top: 15px;
            font-size: 1.1em;
        }

        /* Layer Comparison Modal */
        #compare-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        #compare-modal.active {
            display: flex;
        }

        .compare-content {
            background: var(--panel-bg);
            border: 2px solid var(--accent-color);
            border-radius: 8px;
            padding: 30px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }

        .compare-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 15px;
        }

        .compare-header h2 {
            margin: 0;
            color: var(--accent-color);
            font-size: 1.5rem;
        }

        .close-modal {
            background: transparent;
            color: #888;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            line-height: 40px;
            text-align: center;
            transition: color 0.2s;
        }

        .close-modal:hover {
            color: var(--accent-color);
        }

        .compare-section {
            margin-bottom: 25px;
        }

        .compare-section h3 {
            color: var(--accent-color);
            font-size: 1.1rem;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .layer-comparison-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
        }

        .layer-comparison-card h4 {
            margin: 0 0 10px 0;
            font-size: 0.9rem;
            color: var(--accent-color);
        }

        .layer-comparison-card .timestamp {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 10px;
        }

        .coverage-metric {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .coverage-metric:last-child {
            border-bottom: none;
        }

        .coverage-metric .label {
            color: #aaa;
            font-size: 0.85rem;
        }

        .coverage-metric .value {
            font-weight: bold;
            font-size: 0.9rem;
        }

        .coverage-diff {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .diff-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .diff-row:last-child {
            border-bottom: none;
        }

        .diff-row .category {
            color: #aaa;
            font-size: 0.85rem;
        }

        .diff-row .change {
            font-weight: bold;
            font-size: 0.9rem;
        }

        .diff-row .change.positive {
            color: var(--success-color);
        }

        .diff-row .change.negative {
            color: var(--danger-color);
        }

        .diff-row .change.neutral {
            color: #888;
        }

        .button-compare {
            background: #9c27b0;
            color: white;
            margin-top: 10px;
        }

        .button-compare:hover {
            background: #7b1fa2;
        }

        .button-compare:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* MOBILE RESPONSIVENESS */
        @media screen and (max-width: 768px) {
            body {
                flex-direction: column; /* Stack elements vertically */
                height: 100dvh; /* Use dynamic viewport height for mobile browsers */
                overflow: hidden;
            }

            #sidebar {
                width: 100%; /* Full width */
                height: 40%; /* Take top 40% of screen */
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                box-shadow: 0 2px 5px rgba(0,0,0,0.5);
                order: 1; /* Ensure sidebar stays on top */
            }

            #main-view {
                width: 100%;
                height: 60%; /* Take remaining 60% */
                order: 2;
            }

            /* Adjust chart sizing */
            #chart {
                padding: 10px;
            }
            
            /* Make tooltip safer on small screens */
            #tooltip {
                max-width: 250px;
                font-size: 0.8rem;
                pointer-events: none; /* Ensure it doesn't block touches */
            }

            /* Adjust controls for touch */
            .tab-button {
                padding: 10px 5px;
                font-size: 0.8rem;
            }
            
            button {
                padding: 12px 15px; /* Larger touch targets */
            }
            
            /* Modal Adjustments */
            .compare-content {
                width: 95%;
                max-height: 90vh;
                padding: 15px;
            }
            
            .comparison-grid {
                grid-template-columns: 1fr; /* Stack comparison cards */
            }
        }
    </style>
</head>
<body>

    <div id="loader" role="alert" aria-busy="true">
        <div class="spinner"></div>
        <div id="loading-text">Accessing MITRE v18 Data...</div>
        <div id="loading-subtext">Fetching enterprise-attack.json</div>
    </div>

    <nav id="sidebar" role="navigation" aria-label="Sidebar">
        <div class="tab-header" role="tablist">
            <button class="tab-button active" onclick="switchTab('overview')" id="tab-btn-overview" 
                    role="tab" aria-selected="true" aria-controls="tab-overview" tabindex="0">
                Overview
            </button>
            <button class="tab-button" onclick="switchTab('layers')" id="tab-btn-layers"
                    role="tab" aria-selected="false" aria-controls="tab-layers" tabindex="0">
                Detection Layers
                <span class="tab-badge" id="layers-badge" aria-label="0 layers">0</span>
            </button>
        </div>

        <div id="tab-overview" class="tab-content active" role="tabpanel" aria-labelledby="tab-btn-overview">
            <h1>DETECTION DEPTH MAP</h1>
            <div class="subtitle">MITRE ATT&CK v18 Native - Mobile Ready</div>

            <div class="score-card">
                <div class="score-label">Global Coverage</div>
                <div class="score-big" id="global-score">0%</div>
                <div style="margin-top: 5px; font-size: 0.8rem; color: #888;">
                    <span id="active-components">0</span> / <span id="total-components">0</span> Data Components Active
                </div>
            </div>

            <div id="node-details" style="display:none; margin-top: 20px;" aria-live="polite">
                <h2>Selection Details</h2>
                <div id="detail-id-badge" class="id-badge"></div>
                <div id="detail-name" style="font-weight:bold; color:white; margin-bottom: 5px; font-size: 0.95rem;"></div>
                <div id="detail-type" style="color:#888; font-size: 0.75rem; margin-bottom: 10px; text-transform: uppercase;"></div>
                <div id="detail-log-source" class="log-source"></div>
                
                <div class="score-card" style="margin-top:15px; background: rgba(0,0,0,0.2);">
                    <div class="score-label">Branch Coverage</div>
                    <div class="score-big" id="node-score">0%</div>
                </div>
                
                <p id="detail-desc" style="font-size: 0.8rem; color: #aaa; line-height: 1.4; max-height: 200px; overflow-y: auto; margin-top: 10px;"></p>
            </div>

            <div class="control-group" style="margin-top: auto; padding-top: 20px;">
                <div style="font-size: 0.75rem; color: #666; margin-bottom: 10px; font-style: italic;">
                    Click to zoom. Right-click for manual toggle (when no layers active).
                </div>
                <button class="secondary" onclick="resetZoom()" aria-label="Reset Zoom">Reset Zoom</button>
            </div>
        </div>

        <div id="tab-layers" class="tab-content" role="tabpanel" aria-labelledby="tab-btn-layers">
            <h1>DETECTION LAYERS</h1>
            <div class="subtitle">Import and manage detection coverage layers</div>

            <div class="file-drop-zone" id="dropZone" tabindex="0" role="button" aria-label="Upload JSON layer file">
                <div style="font-size: 0.9rem; margin-bottom: 5px;">Drop v18 Detection Layer JSON</div>
                <div class="help-text">or click to browse</div>
            </div>
            <input type="file" id="file-input" accept=".json" multiple aria-hidden="true">

            <div id="layers-list" role="list">
                </div>

            <div class="control-group">
                <button onclick="exportActiveLayers()" id="exportBtn">Export Active Layers</button>
                <button class="button-compare" onclick="showCompareModal()" id="compareBtn" disabled>Compare Layers (2)</button>
                <button class="secondary" onclick="clearAllLayers()" id="clearBtn">Clear All Layers</button>
            </div>

            <div class="collapsible-section" style="margin-top: 15px;">
                <div class="collapsible-header" onclick="toggleCollapsible('schema-help')" tabindex="0" role="button" aria-expanded="false" aria-controls="schema-help">
                    <span style="font-size: 0.85rem; font-weight: bold;">Schema Reference</span>
                    <span id="schema-help-icon">▼</span>
                </div>
                <div class="collapsible-content" id="schema-help">
                    <div class="schema-example">
{
  "name": "SIEM Coverage", // [Required] Unique Layer Name
  "version": "1.0",
  "domain": "enterprise-attack",
  "description": "Production detections",
  "detections": [
    {
      "ruleName": "High Volume Auth Failures",
      "ruleId": "SENT-BF-001",
      "tactics": ["credential-access"],
      "techniques": ["T1110"],
      "subtechniques": ["T1110.003"],
      "detectionStrategies": ["DET0487"],
      "analytics": ["AN1336"],
      "dataComponents": ["DS0028"],
      "tables": ["SigninLogs"],
      "score": 1.0,
      "enabled": true
    }
  ]
}
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <main id="main-view" role="main">
        <div id="breadcrumbs" aria-live="polite">ATT&CK Enterprise</div>
        <div id="chart"></div>
    </main>
    
    <div id="tooltip" role="tooltip"></div>

    <div id="compare-modal" role="dialog" aria-labelledby="modal-title" aria-modal="true">
        <div class="compare-content">
            <div class="compare-header">
                <h2 id="modal-title">Layer Comparison</h2>
                <button class="close-modal" onclick="closeCompareModal()" aria-label="Close modal">×</button>
            </div>

            <div class="compare-section">
                <h3>Time Range</h3>
                <div class="coverage-diff">
                    <div class="diff-row">
                        <span class="category">Time Difference</span>
                        <span class="change" id="comp-time-diff">-</span>
                    </div>
                </div>
            </div>

            <div class="compare-section">
                <h3>Layer Details</h3>
                <div class="comparison-grid">
                    <div class="layer-comparison-card">
                        <h4 id="comp-older-name">Older Layer</h4>
                        <div class="timestamp" id="comp-older-timestamp">-</div>
                        <div class="coverage-metric">
                            <span class="label">Global Coverage</span>
                            <span class="value" id="comp-older-coverage">-</span>
                        </div>
                        <div class="coverage-metric">
                            <span class="label">Detection Rules</span>
                            <span class="value" id="comp-older-rules">-</span>
                        </div>
                    </div>
                    <div class="layer-comparison-card">
                        <h4 id="comp-newer-name">Newer Layer</h4>
                        <div class="timestamp" id="comp-newer-timestamp">-</div>
                        <div class="coverage-metric">
                            <span class="label">Global Coverage</span>
                            <span class="value" id="comp-newer-coverage">-</span>
                        </div>
                        <div class="coverage-metric">
                            <span class="label">Detection Rules</span>
                            <span class="value" id="comp-newer-rules">-</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="compare-section">
                <h3>Coverage Changes</h3>
                <div class="coverage-diff">
                    <div class="diff-row">
                        <span class="category">Global Coverage</span>
                        <span class="change" id="comp-diff-global">-</span>
                    </div>
                    <div class="diff-row">
                        <span class="category">Tactics</span>
                        <span class="change" id="comp-diff-tactics">-</span>
                    </div>
                    <div class="diff-row">
                        <span class="category">Techniques</span>
                        <span class="change" id="comp-diff-techniques">-</span>
                    </div>
                    <div class="diff-row">
                        <span class="category">Sub-Techniques</span>
                        <span class="change" id="comp-diff-subtechniques">-</span>
                    </div>
                    <div class="diff-row">
                        <span class="category">Detection Strategies</span>
                        <span class="change" id="comp-diff-strategies">-</span>
                    </div>
                    <div class="diff-row">
                        <span class="category">Analytics</span>
                        <span class="change" id="comp-diff-analytics">-</span>
                    </div>
                    <div class="diff-row">
                        <span class="category">Data Components</span>
                        <span class="change" id="comp-diff-datacomponents">-</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <button onclick="copyComparisonAsMarkdown()">Copy as Markdown Table</button>
                <button class="secondary" onclick="closeCompareModal()">Close</button>
            </div>
        </div>
    </div>

<script>
    // ============================================================================
    // SECURITY & UTILITY FUNCTIONS
    // ============================================================================
    
    /**
     * Escape HTML to prevent XSS attacks
     */
    function escapeHtml(text) {
        if (text === null || text === undefined) return '';
        const div = document.createElement('div');
        div.textContent = String(text);
        return div.innerHTML;
    }
    
    /**
     * Sanitize color values to prevent CSS injection
     */
    function sanitizeColor(color) {
        if (!color || typeof color !== 'string') return '#00bcd4';
        // Only allow hex colors
        if (!/^#[0-9A-Fa-f]{6}$/.test(color)) {
            return '#00bcd4';
        }
        return color;
    }
    
    /**
     * Validate and sanitize string with max length and control char removal
     */
    function sanitizeString(str, maxLength = 200) {
        if (typeof str !== 'string') return '';
        // Remove control characters (ASCII 0-31) except newlines
        const sanitized = str.replace(/[\x00-\x09\x0B-\x1F\x7F]/g, "");
        return sanitized.substring(0, maxLength);
    }
    
    /**
     * Validate array of strings
     */
    function sanitizeStringArray(arr) {
        if (!Array.isArray(arr)) return [];
        return arr.filter(item => typeof item === 'string').map(item => sanitizeString(item, 100));
    }

    /**
     * Safe JSON Parse to prevent Prototype Pollution
     */
    function safeJSONParse(jsonString) {
        return JSON.parse(jsonString, (key, value) => {
            // Block dangerous keys
            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
                return undefined;
            }
            return value;
        });
    }
    
    /**
     * Notification System for consistent user feedback
     */
    const NotificationSystem = {
        error: function(title, message, details = null) {
            console.error(title, message, details);
            this.show(title, message, 'error', details);
        },
        
        warning: function(title, message, details = null) {
            console.warn(title, message);
            this.show(title, message, 'warning', details);
        },
        
        success: function(title, message) {
            console.log(title, message);
            this.show(title, message, 'success');
        },
        
        info: function(title, message) {
            console.info(title, message);
            this.show(title, message, 'info');
        },

        undo: function(title, message, undoCallback) {
            const notification = this.show(title, message, 'info', null, false);
            const actions = document.createElement('div');
            actions.className = 'notification-actions';
            const undoBtn = document.createElement('button');
            undoBtn.className = 'notification-btn';
            undoBtn.textContent = 'Undo';
            undoBtn.onclick = () => {
                undoCallback();
                if (notification.parentNode) notification.parentNode.removeChild(notification);
            };
            actions.appendChild(undoBtn);
            notification.appendChild(actions);
        },
        
        show: function(title, message, type, details = null, autoDismiss = true) {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.setAttribute('role', 'alert');
            
            let detailsHtml = '';
            if (details) {
                detailsHtml = `<details><summary>Details</summary><pre>${escapeHtml(JSON.stringify(details, null, 2))}</pre></details>`;
            }
            
            notification.innerHTML = `
                <strong>${escapeHtml(title)}</strong>
                <div>${escapeHtml(message)}</div>
                ${detailsHtml}
            `;
            
            document.body.appendChild(notification);
            
            if (autoDismiss) {
                setTimeout(() => {
                    notification.style.transition = 'opacity 0.5s, transform 0.5s';
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(400px)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            document.body.removeChild(notification);
                        }
                    }, 500);
                }, 8000);
            }
            return notification;
        }
    };
    
    /**
     * Rate limiter for localStorage saves
     */
    let lastSaveTime = 0;
    const SAVE_COOLDOWN = 1000; // 1 second
    
    /**
     * Validation schema for detection layers
     */
    function validateDetection(det) {
        if (!det || typeof det !== 'object') return null;
        
        // Required fields
        if (!det.ruleName || !det.ruleId) return null;
        
        // Must have at least one of: techniques or dataComponents
        const hasTechniques = Array.isArray(det.techniques) && det.techniques.length > 0;
        const hasDataComponents = Array.isArray(det.dataComponents) && det.dataComponents.length > 0;
        
        if (!hasTechniques && !hasDataComponents) return null;
        
        // Sanitize and return
        return {
            ruleName: sanitizeString(det.ruleName, 200),
            ruleId: sanitizeString(det.ruleId, 100),
            tactics: sanitizeStringArray(det.tactics || []),
            techniques: sanitizeStringArray(det.techniques || []),
            subtechniques: sanitizeStringArray(det.subtechniques || []),
            detectionStrategies: sanitizeStringArray(det.detectionStrategies || []),
            analytics: sanitizeStringArray(det.analytics || []),
            dataComponents: sanitizeStringArray(det.dataComponents || []),
            tables: sanitizeStringArray(det.tables || []),
            score: typeof det.score === 'number' ? Math.max(0, Math.min(1, det.score)) : 1.0,
            enabled: det.enabled !== false
        };
    }
    
    /**
     * Validate layer structure
     */
    function validateLayerStructure(layer) {
        return layer && 
               typeof layer.id === 'number' && 
               layer.id > 0 &&
               layer.id < 1000000 &&
               typeof layer.name === 'string' && 
               Array.isArray(layer.detections) &&
               typeof layer.enabled === 'boolean';
    }

    // ============================================================================
    // GLOBAL STATE
    // ============================================================================
    
    const MITRE_STIX_URL = "https://raw.githubusercontent.com/mitre-attack/attack-stix-data/master/enterprise-attack/enterprise-attack.json";
    const MITRE_STIX_URL_FALLBACK = "https://cdn.jsdelivr.net/gh/mitre-attack/attack-stix-data@master/enterprise-attack/enterprise-attack.json";
    
    let fullDataset = null;
    let svg, g, path, root, partition, arc, radius;
    let detectionLayers = [];
    let layerIdCounter = 0;
    let initializationComplete = false;
    let activeTab = 'overview'; // Track active tab
    
    // Event handler references to prevent memory leaks
    const eventHandlers = {
        click: null,
        contextmenu: null,
        mouseover: null,
        mouseout: null
    };
    
    // ============================================================================
    // TAB MANAGEMENT
    // ============================================================================
    
    /**
     * Switch between sidebar tabs
     */
    function switchTab(tabName) {
        // Hide all tabs
        document.querySelectorAll('.tab-content').forEach(tab => {
            tab.classList.remove('active');
        });
        
        // Deactivate all tab buttons
        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.remove('active');
            btn.setAttribute('aria-selected', 'false');
        });
        
        // Show selected tab
        const targetTab = document.getElementById(`tab-${tabName}`);
        const targetButton = document.getElementById(`tab-btn-${tabName}`);
        
        if (targetTab) {
            targetTab.classList.add('active');
        }
        
        if (targetButton) {
            targetButton.classList.add('active');
            targetButton.setAttribute('aria-selected', 'true');
        }
        
        activeTab = tabName;
        
        // Save preference to localStorage
        try {
            localStorage.setItem('mitre_v18_active_tab', tabName);
        } catch (error) {
            console.warn('Failed to save tab preference:', error);
        }
        
        console.log(`Switched to tab: ${tabName}`);
    }
    
    /**
     * Load saved tab preference - Synchronous to prevent flicker
     */
    function loadTabPreference() {
        try {
            const savedTab = localStorage.getItem('mitre_v18_active_tab');
            if (savedTab && (savedTab === 'overview' || savedTab === 'layers')) {
                // Manually set class without calling full switchTab yet if needed
                activeTab = savedTab;
            }
        } catch (error) {
            console.warn('Failed to load tab preference:', error);
        }
    }
    
    // Make switchTab available globally
    window.switchTab = switchTab;
    
    // ============================================================================
    // LAYER COMPARISON
    // ============================================================================
    
    let comparisonData = null; // Store comparison results
    
    /**
     * Show the layer comparison modal
     */
    function showCompareModal() {
        if (detectionLayers.length !== 2) {
            NotificationSystem.warning('Compare Layers', 'Exactly 2 layers must be loaded to compare');
            return;
        }
        
        // Perform comparison
        comparisonData = compareLayers(detectionLayers[0], detectionLayers[1]);
        
        if (!comparisonData) {
            NotificationSystem.error('Compare Failed', 'Unable to compare layers. Ensure both layers have timestamp fields.');
            return;
        }
        
        // Populate modal with comparison data
        populateComparisonModal(comparisonData);
        
        // Show modal
        const modal = document.getElementById('compare-modal');
        modal.classList.add('active');
        modal.querySelector('.close-modal').focus();
    }
    
    /**
     * Close the comparison modal
     */
    function closeCompareModal() {
        document.getElementById('compare-modal').classList.remove('active');
        document.getElementById('compareBtn').focus();
    }
    
    /**
     * Compare two layers and calculate differences
     */
    function compareLayers(layer1, layer2) {
        // Validate timestamps
        const ts1 = layer1.timestamp ? new Date(layer1.timestamp) : null;
        const ts2 = layer2.timestamp ? new Date(layer2.timestamp) : null;
        
        // Use current time if timestamp missing, but warn
        const safeTs1 = (ts1 && !isNaN(ts1.getTime())) ? ts1 : new Date();
        const safeTs2 = (ts2 && !isNaN(ts2.getTime())) ? ts2 : new Date();

        // Determine older and newer
        const older = safeTs1 < safeTs2 ? layer1 : layer2;
        const newer = safeTs1 < safeTs2 ? layer2 : layer1;
        const olderDate = safeTs1 < safeTs2 ? safeTs1 : safeTs2;
        const newerDate = safeTs1 < safeTs2 ? safeTs2 : safeTs1;
        
        // Calculate time difference in days
        const timeDiffMs = newerDate - olderDate;
        let timeDiffDays = Math.ceil(timeDiffMs / (1000 * 60 * 60 * 24));
        
        // Round up to 1 day if within 24 hours
        if (timeDiffDays === 0) {
            timeDiffDays = 1;
        }
        
        // Calculate coverage for each layer
        const olderCoverage = calculateLayerCoverage(older);
        const newerCoverage = calculateLayerCoverage(newer);
        
        // Calculate differences
        const diffs = {
            global: newerCoverage.global - olderCoverage.global,
            tactics: newerCoverage.tactics - olderCoverage.tactics,
            techniques: newerCoverage.techniques - olderCoverage.techniques,
            subtechniques: newerCoverage.subtechniques - olderCoverage.subtechniques,
            strategies: newerCoverage.strategies - olderCoverage.strategies,
            analytics: newerCoverage.analytics - olderCoverage.analytics,
            dataComponents: newerCoverage.dataComponents - olderCoverage.dataComponents
        };
        
        return {
            older: {
                name: older.name,
                timestamp: olderDate,
                coverage: olderCoverage,
                rules: older.detections.length
            },
            newer: {
                name: newer.name,
                timestamp: newerDate,
                coverage: newerCoverage,
                rules: newer.detections.length
            },
            timeDiffDays: timeDiffDays,
            diffs: diffs
        };
    }
    
    /**
     * Calculate coverage percentages for a single layer (Optimized)
     */
    function calculateLayerCoverage(layer) {
        if (!fullDataset) {
            return {
                global: 0,
                tactics: 0,
                techniques: 0,
                subtechniques: 0,
                strategies: 0,
                analytics: 0,
                dataComponents: 0
            };
        }
        
        // PERFORMANCE: Use structuredClone instead of JSON.parse/stringify
        const tempDataset = structuredClone(fullDataset);
        
        // Reset all activation states
        resetActivationStates(tempDataset);
        
        // Apply only this layer
        layer.detections.forEach(detection => {
            if (detection.enabled === false) return;
            
            const techniques = [...(detection.techniques || []), ...(detection.subtechniques || [])];
            const strategies = detection.detectionStrategies || [];
            const analytics = detection.analytics || [];
            const dataComponents = detection.dataComponents || [];
            
            activateContextual(tempDataset, {
                techniques: techniques,
                strategies: strategies,
                analytics: analytics,
                dataComponents: dataComponents,
                layerId: layer.id,
                ruleName: detection.ruleName
            });
        });
        
        // Calculate coverage
        calculateCoverage(tempDataset);
        
        // Count coverage by type
        const counts = countCoverageByType(tempDataset);
        
        return {
            global: Math.round(tempDataset.score * 100),
            tactics: counts.tactics.percentage,
            techniques: counts.techniques.percentage,
            subtechniques: counts.subtechniques.percentage,
            strategies: counts.strategies.percentage,
            analytics: counts.analytics.percentage,
            dataComponents: counts.dataComponents.percentage
        };
    }
    
    /**
     * Count coverage by node type
     */
    function countCoverageByType(node) {
        const counts = {
            tactics: { total: 0, active: 0, percentage: 0 },
            techniques: { total: 0, active: 0, percentage: 0 },
            subtechniques: { total: 0, active: 0, percentage: 0 },
            strategies: { total: 0, active: 0, percentage: 0 },
            analytics: { total: 0, active: 0, percentage: 0 },
            dataComponents: { total: 0, active: 0, percentage: 0 }
        };
        
        function traverse(n) {
            if (!n) return;
            
            // Count by type
            if (n.type === 'Tactic') {
                counts.tactics.total++;
                if (n.score > 0) counts.tactics.active++;
            } else if (n.type === 'Technique') {
                counts.techniques.total++;
                if (n.score > 0) counts.techniques.active++;
            } else if (n.type === 'Sub-Technique') {
                counts.subtechniques.total++;
                if (n.score > 0) counts.subtechniques.active++;
            } else if (n.type === 'Detection Strategy') {
                counts.strategies.total++;
                if (n.score > 0) counts.strategies.active++;
            } else if (n.type === 'Analytic') {
                counts.analytics.total++;
                if (n.active) counts.analytics.active++;
            } else if (n.type === 'Data Component') {
                counts.dataComponents.total++;
                if (n.active) counts.dataComponents.active++;
            }
            
            // Recurse
            if (n.children && n.children.length > 0) {
                n.children.forEach(child => traverse(child));
            }
        }
        
        traverse(node);
        
        // Calculate percentages
        Object.keys(counts).forEach(key => {
            if (counts[key].total > 0) {
                counts[key].percentage = Math.round((counts[key].active / counts[key].total) * 100);
            }
        });
        
        return counts;
    }
    
    /**
     * Populate the comparison modal with data
     */
    function populateComparisonModal(data) {
        // Time difference
        const dayText = data.timeDiffDays === 1 ? '1 day' : `${data.timeDiffDays} days`;
        document.getElementById('comp-time-diff').textContent = dayText;
        
        // Older layer
        document.getElementById('comp-older-name').textContent = data.older.name;
        document.getElementById('comp-older-timestamp').textContent = data.older.timestamp.toLocaleString();
        document.getElementById('comp-older-coverage').textContent = `${data.older.coverage.global}%`;
        document.getElementById('comp-older-rules').textContent = data.older.rules;
        
        // Newer layer
        document.getElementById('comp-newer-name').textContent = data.newer.name;
        document.getElementById('comp-newer-timestamp').textContent = data.newer.timestamp.toLocaleString();
        document.getElementById('comp-newer-coverage').textContent = `${data.newer.coverage.global}%`;
        document.getElementById('comp-newer-rules').textContent = data.newer.rules;
        
        // Differences
        setDiffElement('comp-diff-global', data.diffs.global);
        setDiffElement('comp-diff-tactics', data.diffs.tactics);
        setDiffElement('comp-diff-techniques', data.diffs.techniques);
        setDiffElement('comp-diff-subtechniques', data.diffs.subtechniques);
        setDiffElement('comp-diff-strategies', data.diffs.strategies);
        setDiffElement('comp-diff-analytics', data.diffs.analytics);
        setDiffElement('comp-diff-datacomponents', data.diffs.dataComponents);
    }
    
    /**
     * Set a difference element with appropriate styling
     */
    function setDiffElement(elementId, diff) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        const sign = diff > 0 ? '+' : '';
        element.textContent = `${sign}${diff}%`;
        
        // Set color class
        element.className = 'change';
        if (diff > 0) {
            element.classList.add('positive');
        } else if (diff < 0) {
            element.classList.add('negative');
        } else {
            element.classList.add('neutral');
        }
    }
    
    /**
     * Copy comparison as markdown table
     */
    function copyComparisonAsMarkdown() {
        if (!comparisonData) {
            NotificationSystem.error('Copy Failed', 'No comparison data available');
            return;
        }
        
        const data = comparisonData;
        const dayText = data.timeDiffDays === 1 ? '1 day' : `${data.timeDiffDays} days`;
        
        // Format differences with signs
        const formatDiff = (diff) => {
            const sign = diff > 0 ? '+' : '';
            return `${sign}${diff}%`;
        };
        
        const markdown = `# Detection Coverage Comparison

## Summary
- **Time Period:** ${dayText}
- **Older Layer:** ${data.older.name} (${data.older.timestamp.toISOString().split('T')[0]})
- **Newer Layer:** ${data.newer.name} (${data.newer.timestamp.toISOString().split('T')[0]})

## Coverage Changes

| Metric | Change |
|--------|--------|
| Days | ${data.timeDiffDays} |
| Global Coverage | ${formatDiff(data.diffs.global)} |
| Tactics | ${formatDiff(data.diffs.tactics)} |
| Techniques | ${formatDiff(data.diffs.techniques)} |
| Sub-Techniques | ${formatDiff(data.diffs.subtechniques)} |
| Detection Strategies | ${formatDiff(data.diffs.strategies)} |
| Analytics | ${formatDiff(data.diffs.analytics)} |
| Data Components | ${formatDiff(data.diffs.dataComponents)} |

## Layer Details

| Layer | Date | Global Coverage | Rules |
|-------|------|-----------------|-------|
| ${data.older.name} | ${data.older.timestamp.toISOString().split('T')[0]} | ${data.older.coverage.global}% | ${data.older.rules} |
| ${data.newer.name} | ${data.newer.timestamp.toISOString().split('T')[0]} | ${data.newer.coverage.global}% | ${data.newer.rules} |
`;
        
        // Copy to clipboard
        navigator.clipboard.writeText(markdown).then(() => {
            NotificationSystem.success('Copied!', 'Comparison copied to clipboard as Markdown');
        }).catch(err => {
            console.error('Failed to copy:', err);
            NotificationSystem.error('Copy Failed', 'Could not copy to clipboard. Check browser permissions.');
        });
    }
    
    /**
     * Update compare button state based on layer count
     */
    function updateCompareButtonState() {
        const compareBtn = document.getElementById('compareBtn');
        if (!compareBtn) return;
        
        if (detectionLayers.length === 2) {
            compareBtn.disabled = false;
        } else {
            compareBtn.disabled = true;
        }
    }
    
    // Make functions available globally
    window.showCompareModal = showCompareModal;
    window.closeCompareModal = closeCompareModal;
    window.copyComparisonAsMarkdown = copyComparisonAsMarkdown;
    
    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    
    async function init() {
        // PRE-LOAD: Set tab before fetching data to prevent flicker
        loadTabPreference();
        if (activeTab) switchTab(activeTab);

        let lastError = null;
        const urlsToTry = [MITRE_STIX_URL, MITRE_STIX_URL_FALLBACK];
        
        for (let i = 0; i < urlsToTry.length; i++) {
            const currentUrl = urlsToTry[i];
            const isFallback = i > 0;
            
            try {
                if (isFallback) {
                    updateLoader("Trying fallback source...", "Attempting CDN mirror");
                    console.log('Primary URL failed, trying fallback:', currentUrl);
                } else {
                    updateLoader("Fetching MITRE v18 Data...", "Download in progress...");
                }
                
                // Setup timeout for fetch
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000); // 60s timeout
                
                const response = await fetch(currentUrl, {
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // Check size before parsing
                const contentLength = response.headers.get('content-length');
                if (contentLength && parseInt(contentLength) > 50 * 1024 * 1024) {
                    throw new Error('Response too large (>50MB)');
                }
                
                // Attempt to parse JSON safely
                let stixData;
                try {
                    const textData = await response.text();
                    stixData = safeJSONParse(textData);
                } catch (parseError) {
                    console.error('JSON parse error:', parseError);
                    throw new Error(`Failed to parse MITRE data. The file may be corrupted. Error: ${parseError.message}`);
                }
                
                // Validate basic structure
                if (!stixData || typeof stixData !== 'object') {
                    throw new Error('Invalid STIX data: response is not a valid JSON object');
                }
                
                if (!Array.isArray(stixData.objects)) {
                    throw new Error('Invalid STIX data structure: missing "objects" array');
                }
                
                console.log(`Successfully loaded MITRE v18 data: ${stixData.objects.length} objects`);
                
                updateLoader("Parsing STIX Bundle...", "Processing objects...");
                
                // Use requestAnimationFrame for better timing
                await new Promise(resolve => requestAnimationFrame(resolve));
                
                const hierarchy = parseStixToHierarchy(stixData);
                
                if (!hierarchy || !hierarchy.children) {
                    throw new Error('Failed to build hierarchy from STIX data');
                }
                
                fullDataset = hierarchy;
                
                // Load saved layers from localStorage
                loadSavedLayers();
                
                applyLayersToCoverage();
                drawChart(fullDataset);
                
                initializationComplete = true;
                document.getElementById("loader").style.display = "none";
                console.log("Visualization complete");
                
                NotificationSystem.success('Initialization Complete', `MITRE ATT&CK v18 data loaded successfully`);
                
                // Success - exit the retry loop
                return;
                
            } catch (error) {
                console.error(`Failed to load from ${currentUrl}:`, error);
                lastError = error;
                
                // If this was the last URL, show error
                if (i === urlsToTry.length - 1) {
                    break;
                }
            }
        }
        
        // If we get here, all URLs failed
        const loaderDiv = document.getElementById("loader");
        loaderDiv.innerHTML = `
            <div style="color: #f44336; text-align: center; max-width: 600px; padding: 20px;">
                <h2 style="margin-bottom: 15px;">Failed to Load MITRE Data</h2>
                <p style="margin-bottom: 20px;">${escapeHtml(lastError.message)}</p>
                <button onclick="location.reload()" style="padding: 10px 20px; font-size: 1em; cursor: pointer; background: #00bcd4; border: none; border-radius: 4px; color: #000; font-weight: bold;">
                    Retry
                </button>
            </div>
        `;
        NotificationSystem.error('Initialization Failed', lastError.message);
    }
    
    function updateLoader(text, subtext) {
        const loadingText = document.getElementById("loading-text");
        const loadingSubtext = document.getElementById("loading-subtext");
        if (loadingText) loadingText.innerText = text;
        if (loadingSubtext) loadingSubtext.innerText = subtext;
    }
    
    function parseStixToHierarchy(stixData) {
        if (!stixData || !stixData.objects) {
            throw new Error("Invalid STIX data structure");
        }
        
        const objects = stixData.objects;
        
        // Index all objects by ID and external ID
        const objectMap = {};
        const externalIdMap = {};
        objects.forEach(obj => {
            objectMap[obj.id] = obj;
            const extId = obj.external_references?.[0]?.external_id;
            if (extId) {
                externalIdMap[extId] = obj;
            }
        });
        
        window.stixObjectMap = objectMap;
        
        const tactics = objects.filter(o => o.type === 'x-mitre-tactic');
        const techniques = objects.filter(o => o.type === 'attack-pattern');
        const detectionStrategies = objects.filter(o => o.type === 'x-mitre-detection-strategy');
        const relationships = objects.filter(o => o.type === 'relationship');
        
        // Build relationship map
        const sourceToTargets = {};
        relationships.forEach(rel => {
            if (!sourceToTargets[rel.source_ref]) {
                sourceToTargets[rel.source_ref] = [];
            }
            sourceToTargets[rel.source_ref].push({
                type: rel.relationship_type,
                target: rel.target_ref
            });
        });
        
        // Create tactics map
        const tacticsMap = {};
        tactics.forEach(tactic => {
            const shortName = tactic.x_mitre_shortname || tactic.name;
            const tacticId = tactic.external_references?.[0]?.external_id || tactic.id;
            
            tacticsMap[tactic.id] = {
                name: sanitizeString(tactic.name, 200),
                shortName: sanitizeString(shortName, 100),
                type: "Tactic",
                id: tacticId,
                stixId: tactic.id,
                description: sanitizeString(tactic.description, 5000),
                _children: []
            };
        });
        
        // Separate techniques and sub-techniques
        const parentTechniques = techniques.filter(t => {
            const extId = t.external_references?.[0]?.external_id;
            return extId && !extId.includes('.'); // No dot means parent technique
        });
        
        const subTechniques = techniques.filter(t => {
            const extId = t.external_references?.[0]?.external_id;
            return extId && extId.includes('.'); // Has dot means sub-technique
        });
        
        // Create a map to store technique nodes by their ID
        const techniqueNodesMap = {};
        
        // Add parent techniques to tactics
        parentTechniques.forEach(technique => {
            const killChainPhases = technique.kill_chain_phases || [];
            const techniqueId = technique.external_references?.[0]?.external_id || technique.id;
            
            killChainPhases.forEach(phase => {
                if (phase.kill_chain_name === 'mitre-attack') {
                    const tacticEntry = Object.values(tacticsMap).find(t => 
                        t.shortName && t.shortName.toLowerCase() === phase.phase_name.toLowerCase()
                    );
                    
                    if (tacticEntry) {
                        const techNode = {
                            name: sanitizeString(technique.name, 200),
                            type: "Technique",
                            id: techniqueId,
                            stixId: technique.id,
                            description: sanitizeString(technique.description, 5000),
                            _children: []
                        };
                        tacticEntry._children.push(techNode);
                        
                        if (!techniqueNodesMap[techniqueId]) {
                            techniqueNodesMap[techniqueId] = [];
                        }
                        techniqueNodesMap[techniqueId].push(techNode);
                    }
                }
            });
        });
        
        // Add sub-techniques
        subTechniques.forEach(subTech => {
            const subTechId = subTech.external_references?.[0]?.external_id;
            if (!subTechId) return;
            
            const parentId = subTechId.split('.')[0];
            const parentNodes = techniqueNodesMap[parentId];
            
            if (parentNodes) {
                parentNodes.forEach(parentNode => {
                    const subTechNode = {
                        name: sanitizeString(subTech.name, 200),
                        type: "Sub-Technique",
                        id: subTechId,
                        stixId: subTech.id,
                        parentTechniqueId: parentId,
                        description: sanitizeString(subTech.description, 5000),
                        _children: []
                    };
                    parentNode._children.push(subTechNode);
                });
            }
        });
        
        // Helper to add strategies
        function addStrategyToNode(node, strategyId, strategy, sourceToTargets, objectMap) {
            const stratNode = {
                name: sanitizeString(strategy.name, 200),
                type: "Detection Strategy",
                id: strategyId,
                stixId: strategy.id,
                description: sanitizeString(strategy.description, 5000),
                children: []
            };
            node._children.push(stratNode);
            
            // Add analytics referenced by this strategy
            const analyticRefs = strategy.x_mitre_analytic_refs || [];
            analyticRefs.forEach(analyticRef => {
                const analytic = objectMap[analyticRef];
                if (analytic && analytic.type === 'x-mitre-analytic') {
                    const analyticId = analytic.external_references?.[0]?.external_id || 'AN-' + analytic.id.slice(-4);
                    
                    const analyticNode = {
                        name: sanitizeString(analytic.name, 200),
                        type: "Analytic",
                        id: analyticId,
                        stixId: analytic.id,
                        description: sanitizeString(analytic.description, 5000),
                        active: false,
                        platforms: sanitizeStringArray(analytic.x_mitre_platforms || []),
                        children: [],
                        layerSources: []
                    };
                    stratNode.children.push(analyticNode);
                    
                    // Add data components
                    const logSourceRefs = analytic.x_mitre_log_source_references || [];
                    logSourceRefs.forEach(logSourceRef => {
                        if (logSourceRef.x_mitre_data_component_ref) {
                            const dataComponent = objectMap[logSourceRef.x_mitre_data_component_ref];
                            if (dataComponent && dataComponent.type === 'x-mitre-data-component') {
                                const dataComponentId = dataComponent.external_references?.[0]?.external_id || 'DC-' + dataComponent.id.slice(-4);
                                
                                // De-duplicate within same analytic
                                if (!analyticNode.children.find(dc => dc.stixId === dataComponent.id)) {
                                    analyticNode.children.push({
                                        name: sanitizeString(dataComponent.name, 200),
                                        type: "Data Component",
                                        id: dataComponentId,
                                        stixId: dataComponent.id,
                                        description: sanitizeString(dataComponent.description, 5000),
                                        active: false,
                                        logSourceName: sanitizeString(logSourceRef.name, 200),
                                        logSourceChannel: sanitizeString(logSourceRef.channel, 200),
                                        layerSources: []
                                    });
                                }
                            }
                        }
                    });
                }
            });
        }
        
        // Link strategies
        detectionStrategies.forEach(strategy => {
            const strategyId = strategy.external_references?.[0]?.external_id || 'DET-' + strategy.id.slice(-4);
            
            const rels = sourceToTargets[strategy.id] || [];
            const detectsRels = rels.filter(r => r.type === 'detects');
            
            detectsRels.forEach(rel => {
                const techniqueId = rel.target;
                const technique = objectMap[techniqueId];
                
                if (technique && technique.type === 'attack-pattern') {
                    const techniqueExtId = technique.external_references?.[0]?.external_id;
                    const isSubTechnique = techniqueExtId && techniqueExtId.includes('.');
                    
                    Object.values(tacticsMap).forEach(tactic => {
                        tactic._children.forEach(parentTech => {
                            if (isSubTechnique) {
                                parentTech._children.forEach(subTech => {
                                    if (subTech.stixId === techniqueId && subTech.type === "Sub-Technique") {
                                        addStrategyToNode(subTech, strategyId, strategy, sourceToTargets, objectMap);
                                    }
                                });
                            } else {
                                if (parentTech.stixId === techniqueId && parentTech.type === "Technique") {
                                    addStrategyToNode(parentTech, strategyId, strategy, sourceToTargets, objectMap);
                                }
                            }
                        });
                    });
                }
            });
        });
        
        // Convert to final structure
        const root = {
            name: "ATT&CK Enterprise",
            type: "Root",
            id: "Enterprise",
            children: Object.values(tacticsMap).map(tactic => ({
                name: tactic.name,
                type: tactic.type,
                id: tactic.id,
                description: tactic.description,
                children: tactic._children.map(tech => ({
                    name: tech.name,
                    type: tech.type,
                    id: tech.id,
                    description: tech.description,
                    children: tech._children.map(child => {
                        if (child.type === "Sub-Technique") {
                            return {
                                name: child.name,
                                type: child.type,
                                id: child.id,
                                parentTechniqueId: child.parentTechniqueId,
                                description: child.description,
                                children: child._children
                            };
                        } else {
                            return child;
                        }
                    })
                }))
            }))
        };
        
        return root;
    }
    
    // ============================================================================
    // LAYER MANAGEMENT FUNCTIONS
    // ============================================================================
    
    function importDetectionLayer(layerData, filename = "Imported Layer") {
        if (!initializationComplete) {
            NotificationSystem.warning('Please Wait', 'Initialization in progress.');
            return null;
        }
        
        try {
            const warnings = [];
            
            if (!layerData.detections || !Array.isArray(layerData.detections)) {
                throw new Error("Invalid layer format: 'detections' array required");
            }
            
            const validDetections = [];
            let skippedCount = 0;
            
            layerData.detections.forEach((det, idx) => {
                const validated = validateDetection(det);
                if (validated) {
                    validDetections.push(validated);
                } else {
                    skippedCount++;
                }
            });
            
            if (validDetections.length === 0) {
                throw new Error("No valid detections found.");
            }
            
            if (skippedCount > 0) {
                warnings.push(`${skippedCount} detection(s) skipped due to missing fields`);
            }
            
            const layerId = ++layerIdCounter;
            const safeName = sanitizeString(layerData.name || filename, 50);

            const layer = {
                id: layerId,
                name: safeName,
                version: sanitizeString(layerData.version || "1.0", 20),
                domain: sanitizeString(layerData.domain || "enterprise-attack", 50),
                description: sanitizeString(layerData.description || "", 1000),
                timestamp: layerData.timestamp || new Date().toISOString(),
                detections: validDetections,
                enabled: true,
                color: getLayerColor(layerId),
                stats: {
                    totalRules: validDetections.length,
                    activatedComponents: 0,
                    missingIds: {
                        techniques: new Set(),
                        strategies: new Set(),
                        analytics: new Set(),
                        dataComponents: new Set()
                    }
                }
            };
            
            detectionLayers.push(layer);
            
            // Render UI
            renderLayersList();
            applyLayersToCoverage();
            updateVisualization();
            saveLayersToStorage();
            switchTab('layers');
            
            if (warnings.length > 0) {
                NotificationSystem.warning('Import Warnings', warnings.join('\n'));
            } else {
                NotificationSystem.success('Layer Imported', `"${layer.name}" loaded successfully`);
            }
            
            return layer;
            
        } catch (error) {
            console.error("Error importing layer:", error);
            NotificationSystem.error('Import Failed', error.message);
            return null;
        }
    }
    
    function applyLayersToCoverage() {
        if (!fullDataset) return;
        
        // Optimize: Batch DOM updates
        requestAnimationFrame(() => {
            // Reset state
            resetActivationStates(fullDataset);
            
            const enabledLayers = detectionLayers.filter(l => l.enabled);
            
            if (enabledLayers.length === 0) {
                calculateCoverage(fullDataset);
                renderLayersList(); // Update UI to reflect 0 components
                return;
            }
            
            enabledLayers.forEach(layer => {
                let activatedCount = 0;
                
                // Reset tracking
                layer.stats.missingIds = {
                    techniques: new Set(),
                    strategies: new Set(),
                    analytics: new Set(),
                    dataComponents: new Set()
                };
                
                layer.detections.forEach(detection => {
                    if (detection.enabled === false) return;
                    
                    const techniques = [...(detection.techniques || []), ...(detection.subtechniques || [])];
                    const strategies = detection.detectionStrategies || [];
                    const analytics = detection.analytics || [];
                    const dataComponents = detection.dataComponents || [];
                    
                    // Track missing IDs
                    techniques.forEach(id => {
                        if (!findNodeById(fullDataset, id, 'Technique')) layer.stats.missingIds.techniques.add(id);
                    });
                    
                    // Activation Logic
                    activatedCount += activateContextual(fullDataset, {
                        techniques, strategies, analytics, dataComponents,
                        layerId: layer.id,
                        ruleName: detection.ruleName
                    });
                });
                
                layer.stats.activatedComponents = activatedCount;
            });
            
            calculateCoverage(fullDataset);
            renderLayersList();
        });
    }
    
    function findNodeById(node, targetId, targetType = null) {
        if (node.id === targetId && (!targetType || node.type === targetType)) {
            return node;
        }
        if (node.children) {
            for (const child of node.children) {
                const found = findNodeById(child, targetId, targetType);
                if (found) return found;
            }
        }
        return null;
    }
    
    function activateContextual(node, context, currentPath = {}) {
        let count = 0;
        
        if (node.type === 'Technique' && context.techniques.includes(node.id)) {
            currentPath.inTechnique = true;
        }
        
        // Check sub-techniques
        if (node.type === 'Sub-Technique') {
            const isDirectlyTargeted = context.techniques.includes(node.id);
            if (isDirectlyTargeted) {
                currentPath.inTechnique = true;
            }
        }
        
        if (node.type === 'Detection Strategy' && context.strategies.includes(node.id)) {
            currentPath.inStrategy = true;
        }
        
        if (node.type === 'Analytic' && context.analytics.includes(node.id)) {
            currentPath.inAnalytic = true;
        }
        
        // Data Component Activation Logic
        if (node.type === 'Data Component' && context.dataComponents.includes(node.id)) {
            const techniqueMatch = context.techniques.length === 0 || currentPath.inTechnique;
            const strategyMatch = context.strategies.length === 0 || currentPath.inStrategy;
            const analyticMatch = context.analytics.length === 0 || currentPath.inAnalytic;
            
            const directActivation = context.strategies.length === 0 && context.analytics.length === 0 &&
                                   context.techniques.length > 0 && context.dataComponents.length > 0;
            
            if ((directActivation && techniqueMatch) || (techniqueMatch && strategyMatch && analyticMatch)) {
                if (!node.layerSources) node.layerSources = [];
                if (!node.layerSources.includes(context.layerId)) {
                    node.layerSources.push(context.layerId);
                }
                node.active = true;
                count++;
            }
        }
        
        if (node.children) {
            node.children.forEach(child => {
                count += activateContextual(child, context, {...currentPath});
            });
        }
        
        return count;
    }
    
    function resetActivationStates(node) {
        node.layerSources = [];
        node.active = false;
        if (node.children) {
            node.children.forEach(child => resetActivationStates(child));
        }
    }
    
    function toggleLayer(layerId) {
        const layer = detectionLayers.find(l => l.id === layerId);
        if (layer) {
            layer.enabled = !layer.enabled;
            applyLayersToCoverage();
            updateVisualization();
            saveLayersToStorage();
        }
    }
    
    function deleteLayer(layerId) {
        const index = detectionLayers.findIndex(l => l.id === layerId);
        if (index !== -1) {
            const deletedLayer = detectionLayers[index];
            detectionLayers.splice(index, 1);
            
            renderLayersList();
            applyLayersToCoverage();
            updateVisualization();
            saveLayersToStorage();
            
            // Undo Functionality
            NotificationSystem.undo(
                'Layer Deleted', 
                `"${deletedLayer.name}" removed`,
                () => {
                    detectionLayers.splice(index, 0, deletedLayer);
                    renderLayersList();
                    applyLayersToCoverage();
                    updateVisualization();
                    saveLayersToStorage();
                }
            );
        }
    }
    
    function exportActiveLayers() {
        const enabled = detectionLayers.filter(l => l.enabled);
        if (enabled.length === 0) {
            NotificationSystem.warning('Export', 'No active layers to export');
            return;
        }
        
        const exportData = {
            layers: enabled.map(l => ({
                name: l.name,
                version: l.version,
                domain: l.domain,
                description: l.description,
                timestamp: new Date().toISOString(),
                detections: l.detections
            }))
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'active_detection_layers.json';
        a.click();
        URL.revokeObjectURL(url);
    }
    
    function clearAllLayers() {
        if (detectionLayers.length === 0) return;
        if (confirm('Delete all layers?')) {
            detectionLayers = [];
            layerIdCounter = 0;
            renderLayersList();
            applyLayersToCoverage();
            updateVisualization();
            saveLayersToStorage();
        }
    }
    
    function renderLayersList() {
        const container = document.getElementById('layers-list');
        const badge = document.getElementById('layers-badge');
        if (badge) {
            badge.textContent = detectionLayers.length;
            badge.setAttribute('aria-label', `${detectionLayers.length} layers`);
        }
        
        updateCompareButtonState();
        
        if (detectionLayers.length === 0) {
            container.innerHTML = '<div class="help-text" style="text-align: center; padding: 20px;">No layers imported yet</div>';
            return;
        }
        
        container.innerHTML = detectionLayers.map(layer => {
            const hasWarnings = layer.stats.activatedComponents === 0 && layer.detections.length > 0;
            const warningClass = hasWarnings ? 'warning' : '';
            const warningHtml = hasWarnings ? 
                `<div class="layer-warning">⚠ No components activated - check IDs</div>` : '';
            
            return `
                <div class="layer-item ${layer.enabled ? 'active' : ''} ${warningClass}">
                    <input type="checkbox" 
                           class="layer-checkbox" 
                           ${layer.enabled ? 'checked' : ''} 
                           onchange="toggleLayer(${layer.id})"
                           aria-label="Toggle layer ${escapeHtml(layer.name)}">
                    <div class="layer-info">
                        <div class="layer-name">
                            <span class="layer-color" style="background: ${sanitizeColor(layer.color)};"></span>
                            ${escapeHtml(layer.name)}
                        </div>
                        <div class="layer-stats">
                            ${layer.detections.length} rules · ${layer.stats.activatedComponents} components
                        </div>
                        ${warningHtml}
                    </div>
                    <div class="layer-actions">
                        <button class="small secondary" onclick="exportLayer(${layer.id})" title="Export" aria-label="Export ${escapeHtml(layer.name)}">↓</button>
                        <button class="small danger" onclick="deleteLayer(${layer.id})" title="Delete" aria-label="Delete ${escapeHtml(layer.name)}">×</button>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    function getLayerColor(layerId) {
        const colors = ['#00bcd4', '#4caf50', '#ff9800', '#e91e63', '#9c27b0', '#ffeb3b', '#00e676', '#ff6e40'];
        return colors[(layerId - 1) % colors.length];
    }
    
    // ============================================================================
    // STORAGE FUNCTIONS
    // ============================================================================
    
    function saveLayersToStorage() {
        const now = Date.now();
        if (now - lastSaveTime < SAVE_COOLDOWN) return;
        lastSaveTime = now;
        
        try {
            const layersForStorage = detectionLayers.map(layer => ({
                ...layer,
                stats: {
                    ...layer.stats,
                    missingIds: {
                        techniques: Array.from(layer.stats.missingIds.techniques || []),
                        strategies: Array.from(layer.stats.missingIds.strategies || []),
                        analytics: Array.from(layer.stats.missingIds.analytics || []),
                        dataComponents: Array.from(layer.stats.missingIds.dataComponents || [])
                    }
                }
            }));
            
            const data = JSON.stringify({ layers: layersForStorage, counter: layerIdCounter });
            localStorage.setItem('mitre_v18_detection_layers', data);
        } catch (error) {
            console.error("Save failed:", error);
            // Handle quota exceeded quietly
        }
    }
    
    function loadSavedLayers() {
        try {
            const saved = localStorage.getItem('mitre_v18_detection_layers');
            if (saved) {
                const data = safeJSONParse(saved);
                if (Array.isArray(data.layers)) {
                    detectionLayers = data.layers
                        .filter(validateLayerStructure)
                        .map(layer => ({
                            ...layer,
                            stats: {
                                ...layer.stats,
                                missingIds: {
                                    techniques: new Set(layer.stats.missingIds?.techniques || []),
                                    strategies: new Set(layer.stats.missingIds?.strategies || []),
                                    analytics: new Set(layer.stats.missingIds?.analytics || []),
                                    dataComponents: new Set(layer.stats.missingIds?.dataComponents || [])
                                }
                            }
                        }));
                }
                if (data.counter) layerIdCounter = data.counter;
                renderLayersList();
            }
        } catch (error) {
            localStorage.removeItem('mitre_v18_detection_layers');
        }
    }
    
    // ============================================================================
    // FILE HANDLERS
    // ============================================================================
    
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('file-input');
    
    // Keyboard support for dropzone
    dropZone.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            if (initializationComplete) fileInput.click();
        }
    });

    dropZone.addEventListener('click', () => {
        if (initializationComplete) fileInput.click();
    });
    
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        if (initializationComplete) dropZone.classList.add('drag-over');
    });
    
    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('drag-over');
    });
    
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('drag-over');
        if (initializationComplete) handleFiles(e.dataTransfer.files);
    });
    
    fileInput.addEventListener('change', (e) => {
        if (initializationComplete) {
            handleFiles(e.target.files);
            fileInput.value = '';
        }
    });
    
    function handleFiles(files) {
        if (files.length === 0) return;
        
        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'layer-import-loading';
        loadingDiv.innerHTML = '<div class="spinner"></div><div>Importing...</div>';
        document.body.appendChild(loadingDiv);
        
        let processed = 0;
        
        Array.from(files).forEach(file => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = safeJSONParse(e.target.result);
                    if (data.layers) {
                        data.layers.forEach(l => importDetectionLayer(l, l.name || file.name));
                    } else {
                        importDetectionLayer(data, file.name);
                    }
                } catch (error) {
                    NotificationSystem.error('Parse Error', file.name);
                } finally {
                    processed++;
                    if (processed === files.length) document.body.removeChild(loadingDiv);
                }
            };
            reader.readAsText(file);
        });
    }
    
    // ============================================================================
    // VISUALIZATION
    // ============================================================================
    
    function calculateCoverage(node) {
        if (!node.children || node.children.length === 0) {
            node.leafCount = (node.type === 'Data Component') ? 1 : 0;
            node.activeLeafCount = (node.active) ? 1 : 0;
            node.score = (node.active) ? 1.0 : 0.0;
            return;
        }
        let total = 0, active = 0;
        node.children.forEach(child => {
            calculateCoverage(child);
            total += child.leafCount;
            active += child.activeLeafCount;
        });
        node.leafCount = total;
        node.activeLeafCount = active;
        node.score = total === 0 ? 0 : (active / total);
    }
    
    function getCoverageColor(score) {
        const colors = [
            '#8B0000', '#B71C1C', '#D32F2F', '#E64A19', '#F57C00',
            '#FBC02D', '#FDD835', '#C0CA33', '#7CB342', '#388E3C'
        ];
        return colors[Math.min(Math.floor(score * 10), 9)];
    }
    
    function drawChart(data) {
        const container = document.getElementById("chart");
        const width = container.clientWidth;
        const height = container.clientHeight;
        radius = Math.min(width, height) / 2 - 10;

        d3.select("#chart").selectAll("*").remove();

        svg = d3.select("#chart")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("role", "img")
            .attr("aria-label", "Sunburst chart showing detection coverage");

        g = svg.append("g")
            .attr("transform", `translate(${width/2},${height/2})`);

        root = d3.hierarchy(data)
            .sum(d => 1)
            .sort((a, b) => b.value - a.value);

        partition = d3.partition().size([2 * Math.PI, radius]);
        partition(root);

        arc = d3.arc()
            .startAngle(d => d.x0)
            .endAngle(d => d.x1)
            .padAngle(0.005)
            .innerRadius(d => d.y0)
            .outerRadius(d => d.y1);

        root.each(d => d.current = d);

        path = g.append("g")
            .selectAll("path")
            .data(root.descendants().slice(1))
            .join("path")
            .attr("fill", d => getCoverageColor(d.data.score || 0))
            .attr("fill-opacity", 0.85)
            .attr("stroke", "#000")
            .attr("stroke-width", 0.5)
            .attr("d", d => arc(d.current))
            .style("cursor", "pointer")
            .attr("role", "graphics-symbol")
            .attr("aria-label", d => `${d.data.name} - ${Math.round((d.data.score||0)*100)}% coverage`);

        path.on("click", clicked)
            .on("contextmenu", rightClicked)
            .on("mouseover", mouseover)
            .on("mouseout", mouseout);

        g.append("circle")
            .attr("r", radius / 4)
            .attr("fill", "#0a0a0a")
            .attr("stroke", "#00bcd4")
            .attr("stroke-width", 2)
            .style("cursor", "pointer")
            .on("click", () => clicked(null, root));

        updateStats();
    }

    function updateVisualization() {
        if (!root || !path) return;
        
        requestAnimationFrame(() => {
            root = d3.hierarchy(fullDataset).sum(d => 1).sort((a, b) => b.value - a.value);
            partition(root);
            root.each(d => d.current = d);
            
            path.data(root.descendants().slice(1))
                .transition().duration(300)
                .attr("fill", d => getCoverageColor(d.data.score || 0));
                
            updateStats();
        });
    }

    function clicked(event, p) {
        if (event) event.preventDefault();
        root.each(d => {
            d.target = {
                x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                y0: d.y0 - p.depth,
                y1: d.y1 - p.depth
            };
        });

        const t = g.transition().duration(750);
        path.transition(t).tween("data", d => {
            const i = d3.interpolate(d.current, d.target);
            return t => d.current = i(t);
        }).attrTween("d", d => () => arc(d.current));

        updateSidePanel(p);
        updateBreadcrumbs(p);
    }

    function rightClicked(event, d) {
        event.preventDefault();
        if (detectionLayers.some(l => l.enabled)) {
            NotificationSystem.warning('Locked', 'Manual toggle disabled when layers are active.');
            return;
        }
        
        const toggle = (node, state) => {
            if (!node.children || node.children.length === 0) {
                if (node.data.type === 'Data Component') node.data.active = state;
            } else {
                node.children.forEach(c => toggle(c, state));
            }
        };
        
        toggle(d, d.data.score < 1);
        calculateCoverage(fullDataset);
        updateVisualization();
        updateSidePanel(d);
    }

    function mouseover(event, d) {
        const tooltip = d3.select("#tooltip");
        const safeName = escapeHtml(d.data.name);
        const safeId = escapeHtml(d.data.id || '');
        const safeType = escapeHtml(d.data.type);
        
        let content = `<div style="font-weight:bold; color:#00bcd4">${safeId}</div>`;
        content += `<div style="font-size:0.8rem">${safeType}</div>`;
        content += `<div>${safeName}</div>`;
        content += `<div style="margin-top:5px; border-top:1px solid #444">Coverage: ${(d.data.score*100).toFixed(0)}%</div>`;
        
        tooltip.style("opacity", 1)
               .html(content)
               .style("left", (event.pageX + 15) + "px")
               .style("top", (event.pageY - 28) + "px");
               
        d3.select(event.currentTarget).attr("stroke", "#00bcd4").attr("stroke-width", 2);
    }

    function mouseout(event) {
        d3.select("#tooltip").style("opacity", 0);
        d3.select(event.currentTarget).attr("stroke", "#000").attr("stroke-width", 0.5);
    }
    
    function updateStats() {
        document.getElementById("global-score").innerText = Math.round((fullDataset.score || 0) * 100) + "%";
        document.getElementById("active-components").innerText = fullDataset.activeLeafCount || 0;
        document.getElementById("total-components").innerText = fullDataset.leafCount || 0;
    }

    function updateSidePanel(d) {
        document.getElementById("node-details").style.display = "block";
        document.getElementById("detail-name").innerText = d.data.name;
        document.getElementById("detail-id-badge").innerText = d.data.id || "N/A";
        document.getElementById("detail-type").innerText = d.data.type;
        document.getElementById("node-score").innerText = Math.round((d.data.score || 0) * 100) + "%";
        document.getElementById("node-score").style.color = getCoverageColor(d.data.score || 0);
        document.getElementById("detail-desc").innerText = d.data.description || "No description available.";
        
        // Handle Log Source visibility safely
        const logDiv = document.getElementById("detail-log-source");
        if (d.data.logSourceName) {
            logDiv.style.display = 'block';
            logDiv.innerText = `Log Source: ${d.data.logSourceName}`;
        } else {
            logDiv.style.display = 'none';
        }
    }

    function updateBreadcrumbs(d) {
        const sequence = d.ancestors().reverse().map(d => d.data.name).join(" > ");
        document.getElementById("breadcrumbs").innerText = sequence;
    }
    
    function resetZoom() {
        if (root) clicked(null, root);
    }
    
    function toggleCollapsible(id) {
        const content = document.getElementById(id);
        const icon = document.getElementById(id + '-icon');
        if (content.classList.contains('open')) {
            content.classList.remove('open');
            icon.textContent = '▼';
            document.querySelector(`[onclick="toggleCollapsible('${id}')"]`).setAttribute('aria-expanded', 'false');
        } else {
            content.classList.add('open');
            icon.textContent = '▲';
            document.querySelector(`[onclick="toggleCollapsible('${id}')"]`).setAttribute('aria-expanded', 'true');
        }
    }
    
    function exportLayer(layerId) {
        const layer = detectionLayers.find(l => l.id === layerId);
        if (layer) {
            const blob = new Blob([JSON.stringify(layer, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${layer.name.replace(/[^a-z0-9]/gi, '_')}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
    }

    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            if (fullDataset && initializationComplete) drawChart(fullDataset);
        }, 250);
    });

    init();
</script>
</body>
</html>
